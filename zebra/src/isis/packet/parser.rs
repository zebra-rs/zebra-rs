use std::{
    fmt::{Display, Formatter, Result},
    process::exit,
};

use nom::{
    error::{make_error, ErrorKind},
    IResult,
};
use nom_derive::*;

const ISIS_IRDP_DISC: u8 = 0x83;

const ISIS_L1LSP_PDU: u8 = 0x12; // L1LSP Pdu Type
const ISIS_L2LSP_PDU: u8 = 0x14; // L2LSP Pdu Type

const ISIS_P2P_IIH_PDU: u8 = 0x11; // P2P IIH Pdu Type
const ISIS_L1LAN_IIH_PDU: u8 = 0x0F; // L1LAN IIH Pdu Type
const ISIS_L2LAN_IIH_PDU: u8 = 0x10; // L2LAN IIH Pdu Type

pub enum IsisPacket {
    Hello(IsisHello),
    L1Lsp(IsisL1Lsp),
}

#[derive(Debug, NomBE)]
pub struct IsisHeader {
    discriminator: u8,
    length_indicator: u8,
    id_extension: u8,
    id_length: u8,
    pdu_type: u8,
    version: u8,
    reserved: u8,
    max_area_addr: u8,
}

impl Display for IsisHeader {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(
            f,
            r#"Interdomain Routing Protocol Discreminator: ISIS (0x{:x})
 Length Indicator: {}
 Version/Protocol ID Extension: {}
 ID Length: {}
 PDU Type: 0x{:x}
 Reserved: {}
 Maximum Area Address: {}"#,
            self.discriminator,
            self.length_indicator,
            self.id_extension,
            self.id_length,
            self.pdu_type,
            self.reserved,
            self.max_area_addr
        )
    }
}

#[derive(Debug, NomBE)]
pub struct IsisL1Lsp {
    header: IsisHeader,
    pdu_length: u16,
    lifetime: u16,
    lsp_id: [u8; 8],
}

impl Display for IsisL1Lsp {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(
            f,
            r#"{}
ISIS Link State Protocol:
 PDU length: {}
 Remaining lifetime: {}
"#,
            self.header, self.pdu_length, self.lifetime
        )
    }
}

#[derive(Debug, NomBE)]
pub struct IsisHello {
    header: IsisHeader,
    pdu_length: u16,
    lifetime: u16,
    lsp_id: [u8; 8],
}

pub fn parse(input: &[u8]) -> IResult<&[u8], IsisPacket> {
    if input.len() < 5 {
        return Err(nom::Err::Error(make_error(input, ErrorKind::LengthValue)));
    }
    let pdu_type = input[4];

    match pdu_type {
        ISIS_L1LSP_PDU => {
            let (input, packet) = IsisL1Lsp::parse(input)?;
            println!("{}", packet);
            Ok((input, IsisPacket::L1Lsp(packet)))
        }
        _ => {
            let (input, packet) = IsisL1Lsp::parse(input)?;
            Ok((input, IsisPacket::L1Lsp(packet)))
        }
    }
}

pub fn parse_test() {
    //  ISIS-all-level-1: ISIS LSP.
    let binary_data: &[u8] = &[
        0x01, 0x80, 0xC2, 0x00, 0x00, 0x14, 0x00, 0x1C, 0x42, 0xE5, 0xC4, 0x21, 0x00, 0xCE, 0xFE,
        0xFE, 0x03, 0x83, 0x1B, 0x01, 0x00, 0x12, 0x01, 0x00, 0x00, 0x00, 0xCB, 0x04, 0x8F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0x0F, 0x44, 0x01, 0x81,
        0x01, 0xCC, 0x01, 0x04, 0x03, 0x49, 0x00, 0x00, 0x89, 0x07, 0x75, 0x62, 0x75, 0x6E, 0x74,
        0x75, 0x31, 0xF2, 0x22, 0xAC, 0x13, 0x00, 0x01, 0x00, 0x02, 0x09, 0xC0, 0x00, 0x1F, 0x40,
        0x01, 0x03, 0x00, 0x3E, 0x80, 0x13, 0x01, 0x00, 0x16, 0x09, 0x00, 0x00, 0x03, 0xE8, 0x01,
        0x03, 0x00, 0x3A, 0x98, 0x17, 0x02, 0x01, 0x08, 0x86, 0x04, 0x01, 0x01, 0x01, 0x01, 0x16,
        0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x0A, 0x19, 0x06, 0x04, 0x0B,
        0x00, 0x00, 0x01, 0x08, 0x04, 0x0B, 0x00, 0x00, 0x02, 0x20, 0x0B, 0x30, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x3A, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
        0x00, 0x0A, 0x19, 0x06, 0x04, 0x0A, 0x00, 0x00, 0x01, 0x08, 0x04, 0x0A, 0x00, 0x00, 0x03,
        0x20, 0x0B, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3A, 0x99, 0x84, 0x04,
        0xAC, 0x13, 0x00, 0x01, 0x87, 0x22, 0x00, 0x00, 0x00, 0x0A, 0x60, 0x01, 0x01, 0x01, 0x01,
        0x08, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x0A, 0x18, 0x0B,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x18, 0x0A, 0x00, 0x00,
    ];

    // Do something with the binary data
    parse(&binary_data[17..]);

    exit(0);
}
